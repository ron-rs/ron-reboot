use ast::{Attribute, Expr, Extension, Ron, SignedInteger, UnsignedInteger};
use basic::{one_char, one_of_chars, one_of_tags, tag};
use combinators::{
    alt2, comma_list1, context, cut, delimited, lookahead, many0, map, pair, preceded, take1_if,
};

pub use self::{
    containers::{list, r#struct, rmap, tuple},
    error::{BaseErrorKind, ErrorTree, Expectation, InputParseErr, InputParseError},
    input::{Input, Location, Offset},
    primitive::{bool, decimal, escaped_string, signed_integer, unescaped_str, unsigned_integer},
};
use crate::utf8_parser::char_categories::is_ident_first_char;

//pub type IResultFatal<'a, O> = Result<(Input<'a>, O), InputParseError<'a>>;
pub type IResultLookahead<'a, O> = Result<(Input<'a>, O), InputParseErr<'a>>;
pub type OutputResult<'a, O> = Result<O, InputParseErr<'a>>;

/// All AST elements generated by the utf8_parser
pub mod ast;
/// Basic parsers which receive `Input`
mod basic;
/// Tables for fast lookup of char categories
mod char_categories;
/// Parser combinators which take one or more parsers and modify / combine them
mod combinators;
/// RON container parsers
mod containers;
/// Parser error collection
mod error;
/// Parsers for arbitrary RON expression
mod expr;
/// `Input` abstraction to slice the input that is being parsed and keep track of the line + column
mod input;
/// RON primitive parsers
mod primitive;
#[cfg(feature = "utf8_parser_serde1")]
mod serde;
#[cfg(test)]
pub mod tests;
/// Utility functions for parsing
mod util;

#[cfg(feature = "utf8_parser_serde1")]
pub use self::serde::from_str;

fn extension_name(input: Input) -> IResultLookahead<Extension> {
    one_of_tags(
        &["unwrap_newtypes", "implicit_some"],
        &[Extension::UnwrapNewtypes, Extension::ImplicitSome],
    )(input)
}

fn attribute_enable(input: Input) -> IResultLookahead<Attribute> {
    let start = preceded(tag("enable"), combinators::ws(one_char('(')));
    let end = one_char(')');

    delimited(
        start,
        map(
            combinators::spanned(comma_list1(extension_name)),
            Attribute::Enable,
        ),
        end,
    )(input)
}

pub fn attribute(input: Input) -> IResultLookahead<Attribute> {
    let start = preceded(
        preceded(lookahead(one_char('#')), combinators::ws(one_char('!'))),
        combinators::ws(one_char('[')),
    );
    let end = one_char(']');

    context(
        "attribute",
        delimited(start, combinators::ws(attribute_enable), end),
    )(input)
}

#[derive(Clone, Debug)]
pub enum ExprClass {
    StructTuple,
    Map,
    StrString,
    List,
    Bool,
    /// Signed or Decimal
    SignedDec,
    Dec,
    /// Unsigned or Decimal
    UnsignedDec,
    LeadingIdent,
}

impl ExprClass {
    pub fn parse(input: Input) -> IResultLookahead<Self> {
        let all_but_ident = one_of_chars(
            "({\"[tf+-.0123456789",
            &[
                ExprClass::StructTuple,
                ExprClass::Map,
                ExprClass::StrString,
                ExprClass::List,
                ExprClass::Bool,
                ExprClass::Bool,
                ExprClass::SignedDec,
                ExprClass::SignedDec,
                ExprClass::Dec,
                ExprClass::Dec,
                ExprClass::UnsignedDec,
                ExprClass::UnsignedDec,
                ExprClass::UnsignedDec,
                ExprClass::UnsignedDec,
                ExprClass::UnsignedDec,
                ExprClass::UnsignedDec,
                ExprClass::UnsignedDec,
                ExprClass::UnsignedDec,
                ExprClass::UnsignedDec,
            ],
        );

        alt2(
            lookahead(all_but_ident),
            map(
                take1_if(
                    is_ident_first_char,
                    Expectation::OneOfExpectations(&[Expectation::Alpha, Expectation::Char('_')]),
                ),
                |_| ExprClass::LeadingIdent,
            ),
        )(input)
    }
}

fn expr_inner(input: Input) -> IResultLookahead<Expr> {
    // Copy input and discard its offset ("peek")
    let (_, expr_class): (Input, ExprClass) = ExprClass::parse(input)?;

    // We could just directly try parsing all of these variants without determining an expr class
    // beforehand. However, for error collection & possibly performance reasons this seems to be
    // the better solution right now.
    match expr_class {
        ExprClass::StructTuple => {
            cut(alt2(map(r#struct, Expr::Struct), map(tuple, Expr::Tuple)))(input)
        }
        ExprClass::Map => map(rmap, Expr::Map)(input),
        ExprClass::StrString => alt2(
            map(lookahead(unescaped_str), Expr::Str),
            map(escaped_string, Expr::String),
        )(input),
        ExprClass::List => map(list, Expr::List)(input),
        ExprClass::Bool => map(bool, Expr::Bool)(input),
        ExprClass::SignedDec => alt2(
            map(decimal, Expr::Decimal),
            map(signed_integer, SignedInteger::to_expr),
        )(input),
        ExprClass::Dec => map(decimal, Expr::Decimal)(input),
        ExprClass::UnsignedDec => alt2(
            map(decimal, Expr::Decimal),
            map(unsigned_integer, UnsignedInteger::to_expr),
        )(input),
        ExprClass::LeadingIdent => map(r#struct, Expr::Struct)(input),
    }
}

pub fn expr(input: Input) -> IResultLookahead<Expr> {
    cut(context("expression", expr_inner))(input)
}

fn ron_inner(input: Input) -> IResultLookahead<Ron> {
    map(
        pair(
            many0(combinators::spanned(attribute)),
            combinators::spanned(expr),
        ),
        |(attributes, expr)| Ron { attributes, expr },
    )(input)
}

pub fn ron(input: &str) -> Result<Ron, InputParseError> {
    let input = Input::new(input);

    match ron_inner(input) {
        Ok((i, ron)) if i.is_empty() => Ok(ron),
        Ok((i, _)) => Err(ErrorTree::expected(i, Expectation::Eof)),
        Err(InputParseErr::Fatal(e)) | Err(InputParseErr::Recoverable(e)) => Err(e),
    }
}
